# -*- coding: utf-8 -*-
"""what  a waste9.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yVGkx9yck1i89dSgo6WSaWrKD8w1kKL3
"""

# Load datasets
import pandas as pd
country_data = pd.read_csv("data/country_level_data.csv", encoding='cp1252')
# Added encoding='latin-1' to handle the different file encoding
country_codebook = pd.read_csv("data/country_level_codebook.csv", encoding='latin-1')

country_data

# Check for missing values
print(country_data.isnull().sum())

country_Newdata = country_data[["iso3c","region_id","country_name","income_id","gdp","population_population_number_of_people","total_msw_total_msw_generated_tons_year","waste_treatment_open_dump_percent","waste_treatment_recycling_percent","waste_treatment_compost_percent"]].drop_duplicates()
country_total_data = country_Newdata.dropna(subset=["total_msw_total_msw_generated_tons_year", "country_name"],inplace=False)
country_total_data

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
# Ensure no missing values are included in the calculation
waste_cols = [
    'waste_treatment_open_dump_percent',
    'waste_treatment_recycling_percent',
    'waste_treatment_compost_percent'
]

# Fill missing values with the mean of the corresponding income group
country_total_data[waste_cols] = country_total_data.groupby('income_id')[waste_cols].transform(
    lambda x: x.fillna(x.mean())
)

# Calculate mean values of waste treatment metrics by income group
waste_summary = country_total_data.groupby('income_id')[waste_cols].mean()

# Plot grouped bar chart
fig, ax = plt.subplots(figsize=(10, 6))
waste_summary.plot(kind='bar', ax=ax, alpha=0.75)

# Add chart labels and title
ax.set_title('Waste Treatment Percentages by Income Group in Countries *Reference plot: Data missing*')
ax.set_xlabel('Income Group')
ax.set_ylabel('Percentage')
ax.set_xticklabels(ax.get_xticklabels(), rotation=45)
ax.legend(title='Waste Treatment Method')
ax.grid(visible=True, linestyle='--', alpha=0.5)

# Add note about income group abbreviations
note = """
LIC: Low-Income Countries
LMC: Lower-Middle-Income Countries
UMC: Upper-Middle-Income Countries
HIC: High-Income Countries
"""
plt.text(
    1.05, 0.5, note, transform=ax.transAxes, fontsize=10,
    verticalalignment='center', bbox=dict(facecolor='white', alpha=0.8)
)

# Display the plot
plt.tight_layout()
plt.show()

import plotly.express as px

# Handle missing values by imputing group mean
country_Newdata['waste_treatment_open_dump_percent'] = country_Newdata.groupby('income_id')[
    'waste_treatment_open_dump_percent'
].transform(lambda x: x.fillna(x.mean()))

# Example: Regional Waste Treatment Visualization
fig = px.bar(country_Newdata, x='region_id', y='waste_treatment_open_dump_percent', color='income_id',
             title="Reference plot: regional Open Dumping by Income Group (Nonnull value: 30%)")

# Add a note to explain the income groups
fig.add_annotation(
    text=(
        "<b>Income Group Key:</b><br>"
        "LIC: Low-Income Countries<br>"
        "LMC: Lower-Middle-Income Countries<br>"
        "UMC: Upper-Middle-Income Countries<br>"
        "HIC: High-Income Countries"
    ),
    xref="paper", yref="paper",
    x=1.1, y=0.5,  # Position to the right of the graph
    showarrow=False,
    align="left",
    font=dict(size=12, color="black"),
    bordercolor="black",
    borderwidth=1,
    bgcolor="lightgrey"
)

fig.show()

import plotly.express as px
# Handle missing values by imputing group mean
country_Newdata['waste_treatment_recycling_percent'] = country_Newdata.groupby('income_id')[
    'waste_treatment_recycling_percent'
].transform(lambda x: x.fillna(x.mean()))

# Example: Regional Waste Treatment Visualization
fig = px.bar(country_Newdata, x='region_id', y='waste_treatment_recycling_percent', color='income_id',title=" Reference plot: regional Waste recycling by Income Group (Nonnull value: 58%)"
)
# Add a note to explain the income groups
fig.add_annotation(
    text=(
        "<b>Income Group Key:</b><br>"
        "LIC: Low-Income Countries<br>"
        "LMC: Lower-Middle-Income Countries<br>"
        "UMC: Upper-Middle-Income Countries<br>"
        "HIC: High-Income Countries"
    ),
    xref="paper", yref="paper",
    x=1.1, y=0.5,  # Position to the right of the graph
    showarrow=False,
    align="left",
    font=dict(size=12, color="black"),
    bordercolor="black",
    borderwidth=1,
    bgcolor="lightgrey"
)

# Update layout to ensure the annotation fits within the figure
fig.update_layout(
    margin=dict(r=200),  # Add space to the right for the annotation
)
fig.show()

# Convert the 'total_msw_total_msw_generated_tons_year' column to numeric type before using nlargest
country_total_data["total_msw_total_msw_generated_tons_year"] = pd.to_numeric(country_total_data["total_msw_total_msw_generated_tons_year"], errors='coerce')

# Filter the top 10 cities based on total waste generated
top_countries = country_total_data.nlargest(10, "total_msw_total_msw_generated_tons_year")

# Dynamically adjust the figure size based on the number of cities
plt.figure(figsize=(max(15, len(top_countries) / 2), 8))  # Adjust width dynamically

# Plot the bar chart
plt.bar(top_countries["country_name"], top_countries["total_msw_total_msw_generated_tons_year"], color='orange')

# Customize the plot
plt.xticks(rotation=90, fontsize=10)  # Rotate X-axis labels for better readability
plt.xlabel("Country Name", fontsize=14)
plt.ylabel("Total MSW Generated (tons/Year)", fontsize=14)
plt.title("Waste Generated by Top 10 Countries", fontsize=16)
plt.grid(axis='y', linestyle='--', alpha=0.7)

# Display the plot
plt.show()

country_total_data["gdp per capita"] = country_total_data["gdp"] / country_total_data["population_population_number_of_people"]
country_total_data["msw per capita"] = country_total_data["total_msw_total_msw_generated_tons_year"] / country_total_data["population_population_number_of_people"]
# Group data by income group and compute average metrics
grouped_metrics = country_total_data.groupby("income_id")[["msw per capita", "gdp per capita"]].mean() # Use column names with spaces

# Boxplot for distribution comparison
plt.figure(figsize=(10, 6))
sns.boxplot(data=country_total_data, x="income_id", y="msw per capita", palette="Set2") # Changed y to "msw per capita"
plt.title("waste generation per Capita across countries by income level", fontsize=16)
plt.xlabel("Income Group", fontsize=14)
plt.ylabel("MSW per Capita", fontsize=14)
plt.grid(axis="y", linestyle="--", alpha=0.7)
plt.tight_layout()
plt.show()

import pandas as pd

# Calculate Q1, Q3, and IQR for each income group
q1 = country_total_data.groupby("income_id")["msw per capita"].quantile(0.25)
q3 = country_total_data.groupby("income_id")["msw per capita"].quantile(0.75)
iqr = q3 - q1

# Define lower and upper bounds for outliers
lower_bound = q1 - 1.5 * iqr
upper_bound = q3 + 1.5 * iqr

# Merge bounds back into the dataset
country_total_data = country_total_data.merge(lower_bound.rename("lower_bound"), on="income_id")
country_total_data = country_total_data.merge(upper_bound.rename("upper_bound"), on="income_id")

# Filter for outliers
outliers = country_total_data[
    (country_total_data["msw per capita"] < country_total_data["lower_bound"]) |
    (country_total_data["msw per capita"] > country_total_data["upper_bound"])
]

# Display the names of countries corresponding to outliers
outlier_countries = outliers[["country_name", "income_id", "msw per capita"]]
print(outlier_countries)

print(country_total_data.isnull().sum())

print(country_codebook.isnull().sum())

country_Newcodebook = country_codebook.dropna(subset=["country_name","year"], inplace=False)
# Changed the first argument to subset=["total_msw_total_msw_generated_tons_year"]
# This will drop rows where "total_msw_total_msw_generated_tons_year" has missing values
country_finalcodebook = country_Newcodebook.iloc[:,0:7]
# Drop rows with missing 'year' and "country_name"
country_Year_codebook = country_finalcodebook.dropna(subset=["year","country_name"],inplace=False)
# Convert the "year" column to integers
country_Year_codebook['year'] = country_Year_codebook['year'].astype(int)
country_Year_codebook

# Filter rows based on the "units" column
tonnes_data1 = country_Year_codebook[country_Year_codebook['measurement'] == 'total_msw_total_msw_generated_tons_year']
tonnes_data1

print(tonnes_data1.isnull().sum())

import pandas as pd

# Perform the merge on common columns
country_com_codebook = pd.merge(
    country_total_data,
    tonnes_data1[["country_name", "year"]],  # Only keep necessary columns from tonnes_data
    how="left",  # Left join to keep all rows from city_com_data
    on="country_name"  # Merge on city_name
)

# Check for missing values
print(country_com_codebook.isnull().sum())

# Drop rows where "year" is NaN
country_com_codebook = country_com_codebook.dropna(subset=["year"])

# Convert the "year" column to integers
country_com_codebook['year'] = country_com_codebook['year'].astype(int)

# Check for missing values
print(country_com_codebook.isnull().sum())

import matplotlib.pyplot as plt



# Fill missing values with the mean for each column
country_com_codebook['waste_treatment_open_dump_percent'].fillna(
    country_com_codebook['waste_treatment_open_dump_percent'].mean(), inplace=True)
country_com_codebook['waste_treatment_recycling_percent'].fillna(
    country_com_codebook['waste_treatment_recycling_percent'].mean(), inplace=True)

# Group data by year and calculate mean percentages for open dump and recycling
yearly_trend_open_dump = country_com_codebook.groupby('year')['waste_treatment_open_dump_percent'].mean()
yearly_trend_recycling = country_com_codebook.groupby('year')['waste_treatment_recycling_percent'].mean()

# Plotting both trends in the same graph
plt.figure(figsize=(10, 6))
plt.plot(yearly_trend_open_dump, label='Open Dump (%)', color='red')
plt.plot(yearly_trend_recycling, label='Recycling (%)', color='green')

# Add titles and labels
plt.title('Country Waste Treatment Trends Over Time')
plt.xlabel('Year')
plt.ylabel('Percentage')
plt.legend()  # Add legend to differentiate the lines
plt.grid(visible=True, linestyle='--', alpha=0.5)

# Show the plot
plt.show()

import matplotlib.pyplot as plt
import pandas as pd

# Assuming `data` is your DataFrame with columns 'year', 'waste_generation', and 'GDP'

# Group data by year and calculate mean values for total_msw_total_msw_generated_tons_year and gdp
# Changed 'waste_generation' to 'total_msw_total_msw_generated_tons_year' and 'GDP' to 'gdp'
yearly_trend = country_com_codebook.groupby('year').agg({
    'total_msw_total_msw_generated_tons_year': 'mean',
    'gdp': 'mean'
}).reset_index()

# Plotting
fig, ax1 = plt.subplots(figsize=(10, 6))

# Plot Waste Generation
# Changed 'waste_generation' to 'total_msw_total_msw_generated_tons_year'
ax1.plot(yearly_trend['year'], yearly_trend['total_msw_total_msw_generated_tons_year'], color='blue', label='Waste Generation')
ax1.set_xlabel('Year')
ax1.set_ylabel('Waste Generation', color='blue')
ax1.tick_params(axis='y', labelcolor='blue')

# Create a second y-axis for GDP
ax2 = ax1.twinx()
# Changed 'GDP' to 'gdp'
ax2.plot(yearly_trend['year'], yearly_trend['gdp'], color='green', label='GDP')
ax2.set_ylabel('GDP', color='green')
ax2.tick_params(axis='y', labelcolor='green')

# Titles and legends
plt.title('Historical Trends of Waste Generation and GDP Over Time')
ax1.legend(loc='upper left')
ax2.legend(loc='upper right')

# Add grid for better readability
plt.grid(visible=True, linestyle='--', alpha=0.5)

plt.show()

import matplotlib.pyplot as plt
import pandas as pd

# Assuming `data` is your DataFrame with columns 'year', 'msw per capita', 'gdp per capita', and 'population_population_number_of_people'

# Group data by year and calculate mean values
yearly_trend = country_com_codebook.groupby('year').agg({
    'msw per capita': 'mean',
    'gdp per capita': 'mean',
    'population_population_number_of_people': 'mean'
}).reset_index()

# Plotting
fig, ax1 = plt.subplots(figsize=(12, 7))

# Plot Waste Generation per capita on primary y-axis
ax1.plot(yearly_trend['year'], yearly_trend['msw per capita'], color='blue', label='Waste Generation per capita')
ax1.set_xlabel('Year')
ax1.set_ylabel('Waste Generation per capita', color='blue')
ax1.tick_params(axis='y', labelcolor='blue')

# Create a second y-axis for GDP per capita
ax2 = ax1.twinx()
ax2.plot(yearly_trend['year'], yearly_trend['gdp per capita'], color='green', label='GDP per capita')
ax2.set_ylabel('GDP per capita', color='green')
ax2.tick_params(axis='y', labelcolor='green')

# Create a third y-axis for Population
ax3 = ax1.twinx()
ax3.spines['right'].set_position(('outward', 60))  # Offset the third axis to the right
ax3.plot(yearly_trend['year'], yearly_trend['population_population_number_of_people'], color='red', label='Population')
ax3.set_ylabel('Population', color='red')
ax3.tick_params(axis='y', labelcolor='red')

# Titles and legends
plt.title('Historical Trends of Waste Generation per capita, GDP per capita, and Population Over Time')
ax1.legend(loc='upper left')
ax2.legend(loc='upper center')
ax3.legend(loc='upper right')

# Add grid for better readability
plt.grid(visible=True, linestyle='--', alpha=0.5)

plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Calculate correlation
correlation = country_com_codebook["gdp per capita"].corr(country_com_codebook["msw per capita"])
print(f"Correlation between GDP per capita and MSW per capita: {correlation:.2f}")

# Extract data
gdp = country_com_codebook["gdp per capita"]
msw = country_com_codebook["msw per capita"]

# Scatter plot
plt.figure(figsize=(10, 6))
plt.scatter(gdp, msw, color='gold', edgecolor='black', alpha=0.7, label="Data Points")

# Add regression line
m, b = np.polyfit(gdp, msw, 1)  # Linear regression: y = mx + b
plt.plot(gdp, m * gdp + b, color='blue', linewidth=2, label=f"Regression Line (y = {m:.2f}x + {b:.2f})")

# Highlight potential outliers
threshold = 2  # Adjust as needed
outliers = (np.abs(msw - (m * gdp + b)) > threshold)
plt.scatter(gdp[outliers], msw[outliers], color='red', edgecolor='black', label="Outliers")

# Title and labels
plt.title(f"Scatter Plot: GDP per Capita vs. MSW per Capita\nCorrelation: {correlation:.2f}")
plt.xlabel("GDP per Capita")
plt.ylabel("MSW per Capita")
plt.legend()
plt.grid(visible=True, linestyle="--", alpha=0.5)

# Show plot
plt.show()